# 5장

## <05-01 검증세트 나누고 전처리 과정 배우기>

### 테스트 세트로 모델을 튜닝하기

 4장에서는 마지막에 loss = 'log' = 로지스틱 회귀함수모델을 사용

→83%의 정확도를 봄

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled.png">

정확도를 더 높이기 위해 로스함수를 hinge 사용 (서포트 벡터 머신 SVM 알고리즘, hinge 손실함수.)

→93%의 정확도

데이터에서 모델이 학습하는 파라미터 = 모델 파라미터 (가중치가 대표적)

모델이 데이터에서 학습 못하는, 사람이 정해주는 것들 = 하이퍼파라미터 (sklearn 텐서플로우 등에서 클래스, 메서드, 매개변수로 전달한다)

여러번의 실행을 통해서 어떤 하이퍼 파라미터가 좋은 것인지 알아냄.

테스트 데이터들에게 좋은 점수가 나오도록 매개변수를 바꾸며 훈련하다보니 테스트세트에 훈련하는 것이 되고, 이러면 실전 투입 시 실전 데이터와의 차이가 클 수 있음   ⇒ 테스트 세트를 최대한 사용하지 않고 마지막에 한두번 사용

일반화 성능 = 실전에 투입했을 때 얻을 수 있는 점수

### 검증 세트 준비

전에는 80프로를 훈련세트로 사용했지만 이번에는 그걸 나눠서

60을 훈련, 20을 검증 세트(개발 세트) 로 나눔

검증세트에서 하이퍼 파라미터 튜닝, best model 찾아서 최종적으로 테스트 세트에서 일반화 성능을 추정

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%201.png">

x_train_all과 y_train_all을 다시 집어넣어서 나눔

x_val, y_val ⇒ 검증세트

### 데이터 전처리와 특성의 스케일을 알아보자

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%202.png">

사과에는 당도, 무게 2개 특성  존재

당도 특성은 1자리수 값, 무게는 3자리수여서 두 특성의 스케일이 다름 → boxplot으로 그렸을 때 두 특성의 범위 차이가 큼 

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%203.png">

가중치를 업데이트할때 특성값이 곱해지는데 이렇게 두 특성의 차이가 크면 가중치에 미치는 영향도 크기 때문에 w1 은 조금씩, w2는 크게 변함 → 좋은 가중치를 찾아가는 속도도 서로 다르게 됨 → w1, w2가 최적점을 찾아가는 속도가 비슷해지도록 스케일의 크기도 바꿔줘야함

### 가중치 기록하고 학습률 적용하기

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%204.png">

learning_rate = 학습률

 w+= w_update시 lr를 곱함

값을 줄여서 천천히 업데이트 하기 위함 이유 =

손실함수의 전역최솟값 부분을 찾아갈 때 가중치가 빨리 변하면(학습률이 너무 높으면) 전역최솟값을 안거치고 넘어갈 수 있기 때문에. 

w2 가중치는 0에서 2000까지 큰 값으로, 0~600까지 변하고

w3는 요동이 심함 → 훈련시 낭비가 되고 있음, 최종값 찾는데 비효율적 ⇒스케일을조정하자

### 스케일을 조정해 모델을 훈련

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%205.png">

표준화 : x에서 평균을 빼고 표준편차로 나눈 방법, 신경망은 표준화를 해야 학습을 잘함  거의 필수

데이터를 표준화로 전처리 하는 것 필수

std가 표준편차 계산 함수

각 특성별로 평균, 표준편차를 구한다

표준화한 x_train_scaled 이용하면 요동없이 빠르게 최종값을 찾을 수 있음

### 검증세트로 모델 성능 평가하기

앞에서 만든 검증세트에 적용해봄 (테스트세트는 사용 안함)

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%206.png">

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%207.png">

원본데이터 사용한 산점도

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%208.png">

변환한 x_train_scaled, x_val_scaled 사용한 산점도

원래의 데이터셋과 변환한 데이터를 이용한 산점도의 상대적 위치가 바뀐 이유는 빼는값, 나누는 값이 바뀌었기 때문이다

이렇게 이동 시 xtrainscaled로 훈련한 모델이 제대로 효과를 발휘하지 않는다 실제 모델 투입 시 샘플 하나만 예측하는 경우가 생길  수 있어서 평균, 표준편차를 구할 수 없음 또 상대적 거리가 바뀐 데이터셋으로 모델을 평가하면 올바른 성능 평가가 불가능함.

⇒검증 세트 전처리 시 훈련 데이터의 평균과 훈련 데이터의 표준편차를 사용해 변환해야 한다

### 올바르게 검증 세트 전처리하기

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%209.png">

train_mean으로 빼고 train_std로 나눠야 함

실전에 투입 시 샘플 하나에서 예측을 할 때도 마찬가지로 train_mean으로 빼고 train_std로 나눈다.

검증세트의 통계값이 아닌 훈련세트의 통계값으로 전처리

## <05-02 과대적합과 과소적합>

### 훈련 세트 vs 정확도

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2010.png">

과대적합 = 훈련세트를 과도하게 학습해서 훈련세트에서는 정확도 높고 손실 낮지만 검증세트에서 정확도가 낮고 손실 높은 현상

모델이 훈련세트에 과대적합 되었다 = 검증세트 or 테스트 세트에 잘 일반화 될 것 같지 않다

과소적합 = 훈련세트의 크기를 키움에 따라 훈련세트와 검증 세트의 정확도가 비슷해지지만 전반적인 정확도가 낮은 모델.

바람직한 모델은 원하는 기대치 정확도에 근접하면서 훈련세트의 정확도가 데이터가 많아짐에 따라 감소하되, 검증세트의 정확도는 높아져서 가까워지는 것

일반적인 딥러닝에서는 모델을 과대적합시킨 다음 규제를 통해 적절한 모델을 만드는 것

뉴런 수, 층의 수를 늘리는 것이 일반적인 과대적합 방법

가중치를 규제, 드롭아웃 방법, 뉴런과 층 수 줄이기 등을 통해 규제

### 에포크 vs 손실 함수

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2011.png">

에포크를 많이 진행할 수록 모델이 훈련세트에 더 잘 학습됨 → 과대적합된 모델이 만들어짐

에포크가 진행할수록 훈련세트 손실은 줄어들지만 검증세트 손실은 어느 지점에서 줄어들다말고 상승하기 시작함

손실, 에포크 그래프로 최적의 에포크 횟수를 찾는 경우가 더 많다

### 모델 복잡도 vs 손실 함수

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2012.png">

복잡한 모델을 만들수록 훈련세트 손실은 감소, 검증세트는 어느 지점에서 다시 상승

### 적절한 편향-분산 트레이드오프 선택

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2013.png">

손실값을 그래프로 그리도록 그래프 변경. 

검증세트에 대한 손실값을 기록 (손실 → 로지스틱 손실)

훈련세트를 fit에 호출할 때 훈련세트 말고 검증 세트도 전달해서 훈련세트로 훈련하고 에포크가 끝난 뒤 검증세트로 손실값을 계산해서 리스트에 추가하도록 바꿈

## <05-03 가중치 규제>

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2014.png">

1은 7번째 점과 차이가 크고 2는 가까워서 더 잘 일반화 될 수 있음

그래프 기울기가 작을수록(=가중치를 줄일수록) 일반화가 좋다고 말할 수 있다

그래프 기울기가 크면 훈련세트에 더 잘 맞는 모델이라 할수있음

오른쪽 그래프는 훈련세트에 다 맞지만 새로운 데이터에 잘 일반화 될수 없음

### L1 규제

손실함수 + L1노름(norm)

L1노름  = 가중치에 절대값을 추가한 것

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2015.png">

⇒그래디언트에서 알파에 가중치의 부호를 곱해 그래디언트를 더함

### L2 규제

손실함수 + L2노름(norm)

L1보다 가중치가 큰 영향을 줌

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2016.png">

L2노름 = 유클리드 거리. 가중치 제곱에 루트를 씌운 값. 보통 L2 제곱해서 루트 없이 사용함  

미분 결과를 보기좋게 하기위해 1/2를 추가한 것이다

⇒ 그래디언트에서 알파에 가중치를 곱해 그래디언트에 더한다

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2017.png">

### 로지스틱 회귀 + L1 규제

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2018.png">

l1 = 0.0001 로 훈련 시 검증세트의 손실이 일찍 생김

0을 기점으로 꽤 큰 가중치들이 있는 것을 볼 수 있음

과대적합

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2019.png">

l1=0.001로 훈련 시 검증세트의 손실이 일찍 생기지 않고 지속됨

0.0001로 했을때보다 가중치가 작게 변화함

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2020.png">

l1=0.01은 규제가 너무 커서 훈련, 검증 모두 손실이 매우 큼

0에 가까운 가중치가 굉장히 많아지고, 0인 가중치도 존재하게됨 모델이 자유도가 억제됨

전형적인 과소적합 모델

### 로지스틱 회귀 + L2 규제

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2021.png">
                                                                                         
l2 = 0.0001시 과대적합 모델이지만 L1보다는 늦게 시작함.

가중치도 0에서 벗어나는 가중치가 굉장히 많은 것을 볼 수 있음

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2022.png">
                                                                                         
l2=0.001 검증세트의 손실값이 상승되는게 0.0001 보다 억제됨

가중치도 적게 변화함

<img src="<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2023.png">

손실점수가 0.1근처로 높아져서 검증세트와 훈련세트의 손실함수가 모두 높아져 과소적합

가중치가 0에 너무 가깝지만 l1만큼은 아님

**⇒보편적으로 L2규제가 좀 더 좋은 모델을 가져서 많이 사용된다**

## <05-04 교차 검증>

훈련세트에서 검증세트를 분리하면 훈련세트가 줄어들 수 밖에 없음. 이를 방지 위해 교차 검증을 사용한다

교차 검증 하는 법 : 일단 테스트 세트를 떨궈냄 (최종에서 사용할 것 ) 

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2024.png">

그 후 5개 폴드로 나눠서 1 2 3 4 5 폴드를 순서대로 한개씩 검증폴드로 두고 나머지 네개를 훈련폴드로 돌림 = 5폴드 교차검증

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2025.png">

cross_validate 사용

보통 신경망에서는 훈련데이터가 매우 커서 여러번 훈련해서 검증 점수를 평균내는 것이 너무 많은 자원을 사용하게돼서 실전에서 적용하기 어려운 점이 있음. 그래서 교차검증은 머신러닝에서는 자주 사용하지만 딥러닝에서는 자주 사용하지 앟음

### 전처리 단계를 포함해 교차검증 수행

<img src="https://github.com/yoon-303/Study/blob/main/5_imgs/Untitled%2026.png">
                                                                                         
 검증세트를 나누지 않고 훈련세트 전체를 사용(검증세트가 훈련세트에 포함되어있음)  

파이프라인 클래스 사용함

standardsclaer() 사용해서 전처리 표준화, 앞의 경사하강법분류기모델 sgd 사용해서 파이프라인 만들음.

훈련세트에서 전처리 통계값 얻은 다음 검증세트를 전처리. (검증세트 따로 전처리하면 안되고 훈련세트의 통계값 이용)

→cross_validate 안에 전체 교차검증 안의 전처리 과정이 들어가야 함

전처리 단계랑 모델 객체(sgd)를 묶어서 하나의 모델로 만들어 주는 것이 파이프라인클래스
